import argparse
from src.cubik import Cubik
from src.solver import Solver

if (__name__ == '__main__'):
    parser = argparse.ArgumentParser(description="Takes a combination of movement to shuffle a Rubik's cube and solve it")
    parser.add_argument("commands", type=str, help="The list of command which must be computed before resolving the Rubik's")
    parser.add_argument("--verbosity", help="Increase the amount of information during the solving process", action="store_true")
    parser.add_argument("--visual", help="Shows the state of the cube after the solving", action="store_true")
    args = parser.parse_args()

    cubik = Cubik(list(range(20)) + 20 * [0], [], True)
    # cubik.rotate('L', (0, 1), 1)
    # cubik.rotate('R', (0, 1), 1)
    # cubik.rotate('U', (0, 1), 1)
    # cubik.rotate('D', (0, 1), 1)
    # cubik.rotate('F', (0, 1), 1)
    # cubik.rotate('B', (0, 1), 1)
    # cubik.rotate('B', (0, 1), 1)
    # cubik.rotate('F', (0, 1), 1)
    # cubik.rotate('D', (0, 1), 1)
    # cubik.rotate('U', (0, 1), 1)
    # cubik.rotate('R', (0, 1), 1)
    # cubik.rotate('L', (0, 1), 1)
    # cubik.rotate('L', (1, 0), 2)
    # cubik.rotate('R', (1, 0), 2)
    # cubik.rotate('U', (1, 0), 2)
    # cubik.rotate('D', (1, 0), 2)
    # cubik.rotate('F', (1, 0), 2)
    # cubik.rotate('B', (1, 0), 2)
    # cubik.rotate('B', (1, 0), 2)
    # cubik.rotate('F', (1, 0), 2)
    # cubik.rotate('D', (1, 0), 2)
    # cubik.rotate('U', (1, 0), 2)
    # cubik.rotate('R', (1, 0), 2)
    # cubik.rotate('L', (1, 0), 2)
    cubik.debug()
    solver = Solver(cubik, args.commands, args.verbosity)
    solution = solver.solve()
    print(solution)
    if (args.visual):
        commands = solver.parseCommands("{} {}".format(args.commands, solution))
        for commandIdx, command in enumerate(commands):
            cubik.rotate(command[0], command[1], command[2])
            print('{}: {} ------------------'.format(commandIdx, solver.moveToMoveString(command)))
            cubik.debug()